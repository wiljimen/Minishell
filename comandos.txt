

### ðŸŸ¢ **InteracciÃ³n con el usuario / Terminal (Readline)**

Estas funciones provienen de la biblioteca **GNU Readline**, usada para manejar entradas de usuario avanzadas (como cuando escribes en una terminal interactiva tipo shell):

* `readline("mensaje")`:
  â†’ Muestra el **mensaje** y espera a que el usuario escriba algo; devuelve lo que se escribiÃ³.
  Es como `fgets` pero mÃ¡s potente (soporta historial, ediciÃ³n de lÃ­nea, etc.).

* `add_history(line)`:
  â†’ AÃ±ade la lÃ­nea que el usuario escribiÃ³ al **historial**, para que pueda navegar con las flechas del teclado.

* `rl_clear_history()`:
  â†’ Borra todo el historial guardado por `add_history`.

* `rl_on_new_line()`:
  â†’ Indica a readline que se ha empezado una nueva lÃ­nea. Se usa cuando controlas tÃº la forma en que se redibuja la lÃ­nea.

* `rl_replace_line("nueva lÃ­nea", 0)`:
  â†’ Reemplaza el contenido de la lÃ­nea actual por "nueva lÃ­nea".

* `rl_redisplay()`:
  â†’ Redibuja la lÃ­nea actual en la terminal (por ejemplo, despuÃ©s de actualizarla con `rl_replace_line`).

---

### ðŸŸ¡ **Entrada/salida estÃ¡ndar**

* `printf()`:
  â†’ Imprime texto en la salida estÃ¡ndar (pantalla), como `printf("Hola %s", nombre);`.

* `write(fd, buffer, nbytes)`:
  â†’ Escribe `nbytes` desde el `buffer` al descriptor de archivo `fd`. Por ejemplo, `write(1, "Hola", 4);`.

---

### ðŸ”µ **GestiÃ³n de memoria**

* `malloc(size)`:
  â†’ Reserva en memoria `size` bytes y devuelve un puntero al inicio de esa memoria.

* `free(ptr)`:
  â†’ Libera la memoria que antes se reservÃ³ con `malloc`.

---

### ðŸ”´ **Archivos y directorios**

* `access(path, mode)`:
  â†’ Verifica si el archivo `path` existe y si se puede leer, escribir, ejecutar, etc.

* `open(path, flags, mode)`:
  â†’ Abre un archivo y devuelve un **file descriptor**.
  Ejemplo: `open("archivo.txt", O_RDONLY)`.

* `read(fd, buffer, nbytes)`:
  â†’ Lee `nbytes` del archivo `fd` y los guarda en `buffer`.

* `close(fd)`:
  â†’ Cierra el archivo `fd`.

* `stat(path, struct stat *buf)`:
  â†’ Rellena una estructura con informaciÃ³n sobre el archivo `path`.

* `lstat()`:
  â†’ Como `stat()`, pero si es un enlace simbÃ³lico, da info del enlace, no del archivo apuntado.

* `fstat(fd, struct stat *buf)`:
  â†’ Como `stat()`, pero usando un descriptor de archivo abierto.

* `unlink(path)`:
  â†’ Elimina un archivo (como `rm` en la terminal).

---

### ðŸŸ£ **Procesos**

* `fork()`:
  â†’ Crea un nuevo proceso (el hijo). Ambos (padre e hijo) continÃºan ejecutando desde la lÃ­nea siguiente.

* `wait(&status)`:
  â†’ El proceso padre espera a que su hijo termine.

* `waitpid(pid, &status, options)`:
  â†’ Espera a que termine un proceso con PID especÃ­fico.

* `wait3()` / `wait4()`:
  â†’ Variantes de `wait` que ademÃ¡s devuelven informaciÃ³n del uso de recursos.

* `execve(path, argv, envp)`:
  â†’ Reemplaza el proceso actual con otro programa (como lanzar otro ejecutable).

* `exit(status)`:
  â†’ Finaliza el proceso actual con un cÃ³digo de salida.

---

### ðŸŸ  **SeÃ±ales**

* `signal(signum, handler)`:
  â†’ Establece una funciÃ³n (`handler`) para manejar una seÃ±al (como Ctrl+C).

* `sigaction(signum, act, oldact)`:
  â†’ MÃ©todo mÃ¡s completo que `signal` para manejar seÃ±ales.

* `kill(pid, sig)`:
  â†’ EnvÃ­a la seÃ±al `sig` al proceso con ID `pid`.

---

### ðŸŸ¢ **Directorio actual y cambios**

* `getcwd(buffer, size)`:
  â†’ Guarda en `buffer` la ruta del directorio actual.

* `chdir(path)`:
  â†’ Cambia el directorio actual al indicado por `path`.

---

### ðŸ”µ **Pipes y duplicaciÃ³n de ficheros**

* `pipe(fd[2])`:
  â†’ Crea un **pipe** (tuberÃ­a): `fd[0]` para leer y `fd[1]` para escribir.

* `dup(fd)`:
  â†’ Duplica el descriptor `fd`.

* `dup2(oldfd, newfd)`:
  â†’ Redirige `newfd` para que apunte al mismo recurso que `oldfd`.

---

### âšª **Directorios**

* `opendir(path)`:
  â†’ Abre un directorio para poder leer su contenido.

* `readdir(dirp)`:
  â†’ Lee la siguiente entrada de un directorio.

* `closedir(dirp)`:
  â†’ Cierra el directorio abierto con `opendir`.

---

### ðŸŸ¤ **Errores**

* `strerror(errno)`:
  â†’ Devuelve un texto que describe el error correspondiente a `errno`.

* `perror("mensaje")`:
  â†’ Imprime el mensaje seguido de una descripciÃ³n del Ãºltimo error (`errno`).

---

### ðŸŸ£ **Terminal**

* `isatty(fd)`:
  â†’ Devuelve si el descriptor `fd` estÃ¡ conectado a una terminal (por ejemplo, `isatty(0)` verifica si la entrada es un teclado).

* `ttyname(fd)`:
  â†’ Devuelve el nombre del terminal asociado con el descriptor.

* `ttyslot()`:
  â†’ Devuelve el nÃºmero del terminal actual (Ãºtil si hay varios).

* `ioctl(fd, cmd, arg)`:
  â†’ Realiza operaciones de control sobre dispositivos (por ejemplo, cambiar modos de la terminal).

---

### ðŸŸ¡ **Variables de entorno**

* `getenv("VAR")`:
  â†’ Devuelve el valor de una variable de entorno.
  Ej: `getenv("HOME")` da el directorio personal.

---

### ðŸŸ¢ **Control de terminal (termcap)**

Estas funciones son de la **biblioteca termcap**, usada para controlar cÃ³mo se comporta la terminal (colores, movimientos del cursor, etc.):

* `tcgetattr(fd, termios *)`:
  â†’ Obtiene la configuraciÃ³n actual de la terminal.

* `tcsetattr(fd, options, termios *)`:
  â†’ Cambia la configuraciÃ³n de la terminal.

* `tgetent(buffer, termtype)`:
  â†’ Inicializa el acceso a las capacidades del terminal (por ejemplo, VT100).

* `tgetflag("co")`:
  â†’ Devuelve si una capacidad del terminal estÃ¡ activa.

* `tgetnum("li")`:
  â†’ Devuelve el nÃºmero asociado a una capacidad (por ejemplo, nÃºmero de lÃ­neas).

* `tgetstr("cl", &area)`:
  â†’ Devuelve la secuencia de escape para una capacidad (como limpiar la pantalla).

* `tgoto(cap, x, y)`:
  â†’ Devuelve la secuencia para mover el cursor a una posiciÃ³n `x`, `y`.

* `tputs(string, affcnt, putc_fn)`:
  â†’ Imprime una secuencia de control (como la devuelta por `tgoto`), usando una funciÃ³n de impresiÃ³n.

